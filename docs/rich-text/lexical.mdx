---
title: Lexical Rich Text
label: Lexical
order: 30
desc: Built by Meta, Lexical is an incredibly powerful rich text editor and it works beautifully within Payload.
keywords: lexical, rich text, editor, headless cms
---

One of Payload's goals is to build the best rich text editor experience that we possibly can. We want to combine the beauty and polish of the Medium editing experience with the strength and features of the Notion editor - all in one place.

Classically, we've used SlateJS to work toward this goal, but building custom elements into Slate has proven to be more difficult than we'd like, and we've been keeping our options open.

<Banner type="warning">
  Payload's Lexical rich text editor is currently in beta. It's stable enough to use as you build on Payload, so if you're up for helping us fine-tune it, you should use it. But if you're looking for stability, use Slate instead.
</Banner>

Lexical is extremely impressive and trivializes a lot of the hard parts of building new elements into a rich text editor. It has a few distinct advantages over Slate, including the following:

1. A "/" menu, which allows editors to easily add new elements while never leaving their keyboard
1. A "hover" toolbar that pops up if you select text
1. It supports Payload blocks natively, directly within your rich text editor
1. Custom elements, called "features", are much easier to build in Lexical vs. Slate

To use the Lexical editor, first you need to install it:

```
npm install @payloadcms/richtext-lexical
```

Once you have it installed, you can pass it to your top-level Payload config as follows:

```ts
import { buildConfig } from 'payload/config'
import { lexicalEditor } from '@payloadcms/richtext-lexical'

export default buildConfig({
  collections: [
    // your collections here
  ],
  // Pass the Lexical editor to the root config
  editor: lexicalEditor({})
})
```

You can also override Lexical settings on a field-by-field basis as follows:

```ts
import { CollectionConfig } from 'payload/types'
import {
  lexicalEditor
} from '@payloadcms/richtext-lexical'

export const Pages: CollectionConfig = {
  slug: 'pages',
  fields: [
    {
      name: 'content',
      type: 'richText',
      // Pass the Lexical editor here and override base settings as necessary
      editor: lexicalEditor({})
    }
  ]
}
```

## Extending the lexical editor with Features

Lexical has been designed with extensibility in mind. Whether you're aiming to introduce new functionalities or tweak the existing ones, Lexical makes it seamless for you to bring those changes to life.

### Features: The Building Blocks
At the heart of Lexical's customization potential are "features." A feature could be anything from a button on a toolbar, an item in a dropdown menu, or even an entirely new node type. While Lexical ships with a set of default features we believe are essential for most use cases, the true power lies in your ability to redefine, expand, or prune these as needed.

### Integrating New Features

To weave in your custom features, utilize the features prop when initializing the Lexical Editor. Here's a basic example of how this is done:

```ts
import {
  BlocksFeature,
  LinkFeature,
  UploadFeature,
  lexicalEditor
} from '@payloadcms/richtext-lexical'
import { Banner } from '../blocks/Banner'
import { CallToAction } from '../blocks/CallToAction'

{
  editor: lexicalEditor({
    features: ({ defaultFeatures }) => [
      ...defaultFeatures,
      LinkFeature({
        // Example showing how to customize the built-in fields
        // of the Link feature
        fields: [
          {
            name: 'rel',
            label: 'Rel Attribute',
            type: 'select',
            hasMany: true,
            options: ['noopener', 'noreferrer', 'nofollow'],
            admin: {
              description:
                'The rel attribute defines the relationship between a linked resource and the current document. This is a custom link field.',
            },
          },
        ],
      }),
      UploadFeature({
        collections: {
          uploads: {
            // Example showing how to customize the built-in fields
            // of the Upload feature
            fields: [
              {
                name: 'caption',
                type: 'richText',
                editor: lexicalEditor(),
              },
            ],
          },
        },
      }),
      // This is incredibly powerful. You can re-use your Payload blocks
      // directly in the Lexical editor as follows:
      BlocksFeature({
        blocks: [
          Banner,
          CallToAction,
        ],
      }),
    ]
  })
}
```

## Generating HTML

The lexical editor saves content in JSON format. However, if you wish to generate HTML, you have two main methods:

1. Generate HTML in the Collection: Add a sibling field in your collection. This field will derive HTML from the JSON content saved. As this makes payload generate and output the HTML, you can directly utilize it in your frontend.
2. Generate HTML in the Frontend: You can convert the JSON to HTML directly within your frontend.

The editor comes with built-in HTML serializers, simplifying the process of converting JSON to HTML.

### Outputting HTML in the Collection:

To add HTML generation directly within the collection, follow the example below:

```ts
import { CollectionConfig } from 'payload/types'

import {
  HTMLConverterFeature,
  lexicalEditor,
  lexicalHTML
} from '@payloadcms/richtext-lexical'

const Pages: CollectionConfig = {
  slug: 'pages',
  fields: [
    {
      name: 'nameOfYourRichTextField',
      type: 'richText',
      editor: lexicalEditor({
        features: ({ defaultFeatures }) => [
          ...defaultFeatures,
          // The HTMLConverter Feature is the feature which manages the HTML serializers. If you do not pass any arguments to it, it will use the default serializers.
          HTMLConverterFeature({}),
        ],
      }),
    },
    lexicalHTML('nameOfYourRichTextField', { name: 'nameOfYourRichTextField_html' }),
  ],
}
```

`lexicalHTML()` creates a new field in your collection, which automatically converts the referenced lexical richText field into HTML through an afterRead hook.

### Generating HTML in the Frontend:
If you prefer converting the JSON to HTML on the frontend, here's a snippet to guide you:

```ts
import type { SerializedEditorState } from 'lexical'
import {
  type SanitizedEditorConfig,
  convertLexicalToHTML,
  consolidateHTMLConverters,
} from '@payloadcms/richtext-lexical'

async function lexicalToHTML(editorData: SerializedEditorState, editorConfig: SanitizedEditorConfig) {
  return await convertLexicalToHTML({
    converters: consolidateHTMLConverters({ editorConfig }),
    data: editorData,
  })
}
```

In this method, we utilize the `convertLexicalToHTML` which is included in `@payloadcms/richtext-lexical` which takes in the serialized editor state and converts it to HTML.

Because every `Feature` is able to provide html converters, and because the `htmlFeature` can modify those or provide their own, we need to consolidate them with the default html Converters using the `consolidateHTMLConverters` function.

### Creating your own HTML Converter

HTML Converters are typed as `HTMLConverter`, which accepts the node type it should handle, and a function that accepts the serialized node from the lexical editor, and outputs the HTML string. Here's the HTML Converter of the Upload node as an example:

```ts
import type { HTMLConverter } from '@payloadcms/richtext-lexical'
import payload from 'payload'

const UploadHTMLConverter: HTMLConverter<SerializedUploadNode> = {
  converter: async ({ node }) => {
    const uploadDocument = await payload.findByID({
      id: node.value.id,
      collection: node.relationTo,
    })
    const url = (payload?.config?.serverURL || '') + uploadDocument?.url

    if (!(uploadDocument?.mimeType as string)?.startsWith('image')) {
      // Only images can be serialized as HTML
      return ``
    }

    return `<img src="${url}" alt="${uploadDocument?.filename}" width="${uploadDocument?.width}"  height="${uploadDocument?.height}"/>`
  },
  nodeTypes: [UploadNode.getType()], // This is the type of the lexical node that this converter can handle. Instead of hardcoding 'upload' we can get the node type directly from the UploadNode, since it's static.
}
```

As you can see, we have access to all the information saved in the node (for the Upload node, this is `value`and `relationTo`) and we can use that to generate the HTML.

The `convertLexicalToHTML` is part of @payloadcms/richtext-lexical automatically handles traversing the editor state and calling the correct converter for each node.

### Adding the HTML Converter to your Feature

If you wrote your own, custom `Feature` for the editor, you don't have to manually pass in the HTML Converter to the serialize function or the `htmlConverter` feature. Instead, it's possible to define the HTML converter directly inside of your `Feature` - it will then be automatically used by the `consolidateHTMLConverters` function. Here's the Upload Feature as an example:

```ts
export const UploadFeature = (props?: UploadFeatureProps): FeatureProvider => {
  return {
    feature: () => {
      return {
        nodes: [
          {
            converters: {
              html: yourHTMLConverter, // <= This is where you define your HTML Converter
            },
            node: UploadNode,
            type: UploadNode.getType(),
            //...
          },
        ],
        plugins: [/*...*/],
        props: props,
        slashMenu: {/*...*/},
      }
    },
    key: 'upload',
  }
}
```

## Headless Editor

Lexical additionally allows you to do a bunch of other conversions natively:
- HTML to Lexical (or, importing HTML into the lexical editor)
- Markdown to Lexical (or, importing Markdown into the lexical editor)
- Lexical to Markdown

Since that usually happens when you do NOT have access to the editor instance (e.g. outside of payload, in your own frontend) you need to initialize a new headless editor instance. Here's an example:

```ts
import { createHeadlessEditor } from '@lexical/headless' // <= make sure this package is installed
import {
  getEnabledNodes,
  sanitizeEditorConfig,
} from '@payloadcms/richtext-lexical'

const yourEditorConfig; // <= your editor config here

const headlessEditor = await createHeadlessEditor({
  nodes: getEnabledNodes({
    editorConfig: sanitizeEditorConfig(yourEditorConfig),
  }),
})
```

## HTML => Lexical

Once you have your headless editor instance, you can use it to convert HTML to Lexical:

```ts
import { $generateNodesFromDOM } from '@lexical/html'
import { $getRoot,$getSelection } from 'lexical'

headlessEditor.update(() => {
  // In a headless environment you can use a package such as JSDom to parse the HTML string.
  const dom = new JSDOM(htmlString)

  // Once you have the DOM instance it's easy to generate LexicalNodes.
  const nodes = $generateNodesFromDOM(editor, dom.window.document)

  // Select the root
  $getRoot().select()

  // Insert them at a selection.
  const selection = $getSelection()
  selection.insertNodes(nodes)
}, { discrete: true })

// Do this if you then want to get the editor JSON
const editorJSON = headlessEditor.getEditorState().toJSON()
```

This has been taken from the [lexical serialization & deserialization docs](https://lexical.dev/docs/concepts/serialization#html---lexical).

### The discrete flag

The `discrete: true` option makes sure that the editor update is immediately committed, so that you immediately have access to read the updated editor state. If you don't need that, it's best to remove the `discrete` flag.

## Markdown to Lexical

This is how you can import markdown into the lexical editor:

```ts
import { $convertFromMarkdownString } from '@lexical/markdown'
import { sanitizeEditorConfig } from '@payloadcms/richtext-lexical'

const yourSanitizedEditorConfig = sanitizeEditorConfig(yourEditorConfig) // <= your editor config here

const markdown = `# Hello World`
headlessEditor.update(() => { $convertFromMarkdownString(markdown, yourSanitizedEditorConfig.features.markdownTransformers }, { discrete: true })

// Do this if you then want to get the editor JSON
const editorJSON = headlessEditor.getEditorState().toJSON()
```

## Lexical to Markdown

This is how you can export your lexical editor into markdown:

```ts
import { $convertToMarkdownString } from '@lexical/markdown'
import { sanitizeEditorConfig } from '@payloadcms/richtext-lexical'
import type { SerializedEditorState } from "lexical"

const yourSanitizedEditorConfig = sanitizeEditorConfig(yourEditorConfig) // <= your editor config here
const yourEditorState: SerializedEditorState // <= your current editor state here

// Import editor state into your headless editor
try {
  headlessEditor.setEditorState(headlessEditor.parseEditorState(yourEditorState)) // This should commit the editor state immediately
} catch (e) {
  logger.error({ err: e }, 'ERROR parsing editor state')
  return ''
}

// Export to markdown
let markdown: string
headlessEditor.getEditorState().read(() => {
  markdown = $convertToMarkdownString(yourSanitizedEditorConfig?.features?.markdownTransformers)
})
```

The `.setEditorState()` function commits your editor state update immediately, so no `discrete: true` flag is required here to be able to read the editor state directly afterwards.


## Coming Soon

Lots more documentation will be coming soon, which will show in detail how to create your own custom features within Lexical.

For now, take a look at the TypeScript interfaces and let us know if you need a hand. Much more will be coming from the Payload team on this topic soon.
